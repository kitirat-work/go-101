# Recursive Function

## องค์ประกอบของ Recursive Function

1. **Base Case (กรณีพื้นฐาน)**  
   เป็นเงื่อนไขที่บอกให้ฟังก์ชันหยุดการทำงานแบบเรียกตัวเอง (recursion) เมื่อเงื่อนไขนี้เป็นจริง ฟังก์ชันจะหยุดเรียกตัวเองและส่งค่ากลับ ตัวอย่างเช่น การนับถึงจำนวนที่กำหนดหรือการตรวจสอบว่าเราได้ถึงจุดสิ้นสุดของการดำเนินการแล้ว

2. **Recursive Case (กรณีเรียกซ้ำ)**  
   เป็นส่วนที่ฟังก์ชันเรียกตัวเองอีกครั้ง โดยมักจะส่งค่าหรือพารามิเตอร์ที่ปรับให้เล็กลงหรือใกล้เคียงกับ base case มากขึ้น ในทุกครั้งที่เรียกซ้ำ ฟังก์ชันจะเข้าใกล้ base case จนกว่าจะหยุดเรียกตัวเอง

## วิธีการเขียน Recursive Function

1. **เขียน Base Case ก่อน**  
   เพื่อป้องกันการวนลูปแบบไม่รู้จบและทำให้ฟังก์ชันรู้ว่าจะหยุดการเรียกซ้ำเมื่อใด  
   ตัวอย่าง:
   ```go
   if n == 0 {
       return 1
   }
   ```

2. **เขียน Recursive Case**  
   ในส่วนนี้จะเป็นการเรียกฟังก์ชันตัวเองด้วยค่าใหม่ที่เข้าใกล้ base case มากขึ้น  
   ตัวอย่าง:
   ```go
   return n * factorial(n - 1)
   ```

3. **ตรวจสอบการทำงานและการทดสอบด้วยค่าเริ่มต้นที่แตกต่างกัน**  
   ควรทดสอบฟังก์ชันด้วยค่า input หลายๆ แบบ เพื่อให้มั่นใจว่ามี base case และทำงานได้ถูกต้อง

## ตัวอย่างการเขียน Recursive Function

```go
func factorial(n int) int {
    if n == 0 { // Base Case
        return 1
    }
    return n * factorial(n - 1) // Recursive Case
}
```

ในตัวอย่างนี้ `factorial` คือฟังก์ชันคำนวณค่าทางคณิตศาสตร์ของตัวเลข โดยมีเงื่อนไขว่าเมื่อ `n == 0` ฟังก์ชันจะหยุดทำงานและส่งค่า `1` กลับมา ส่วนกรณีเรียกซ้ำจะทำงานเมื่อ `n > 0` โดยเรียกตัวเองใหม่และลดค่า `n` ลงเรื่อยๆ จนถึง base case

## ข้อดีของ Recursive Function

- ช่วยให้โค้ดกระชับและเข้าใจง่ายในบางปัญหา เช่น การหาค่า factorial, การหาลำดับของ Fibonacci หรือการหาค่าของโครงสร้างข้อมูลแบบต้นไม้ (tree)
- สามารถแก้ปัญหาที่มีโครงสร้างซ้ำซ้อนได้อย่างง่ายดาย

## ข้อควรระวัง

- การเขียน Recursive Function ที่ไม่มี base case หรือการเรียกซ้ำที่ไม่ได้เข้าใกล้ base case จะทำให้เกิดการวนลูปไม่สิ้นสุด
- ควรระมัดระวังเรื่องการใช้หน่วยความจำ เนื่องจาก Recursive Function อาจทำให้เกิด stack overflow เมื่อมีการเรียกซ้ำมากเกินไป

---
ในตัวอย่างนี้มีสองฟังก์ชันที่ใช้เพื่อสร้างโฟลเดอร์จาก path ที่กำหนดให้หากโฟลเดอร์นั้นยังไม่มีอยู่ โดยแต่ละฟังก์ชันมีการดำเนินการที่แตกต่างกันดังนี้:

## 1. ฟังก์ชัน `createPath`

ฟังก์ชันนี้ใช้การวนลูป (loop) เพื่อตรวจสอบและสร้างโฟลเดอร์ทุกระดับของ path โดยมีลักษณะการทำงานดังนี้:

### ขั้นตอนการทำงาน:

1. **จัดการ Path ที่รับเข้ามา**:  
   - หาก path เริ่มต้นด้วย `/` ให้ตัด `/` ที่จุดเริ่มต้นออก (`path = path[1:]`)
   - ถ้า path ไม่มี `/` ที่จุดสิ้นสุด ให้เพิ่ม `/` เข้าไปที่ท้ายสุด (`path = path + "/"`)

2. **วนลูปเพื่อสร้างโฟลเดอร์**:  
   - ใช้ลูป `for` เพื่อไล่ผ่านทุกอักขระใน path และตรวจสอบว่าเจอ `/` ที่ใด
   - ทุกครั้งที่เจอ `/` จะนำ path ก่อนหน้านั้นมาทำเป็นโฟลเดอร์ (`dir := path[:i]`)
   - ตรวจสอบว่าโฟลเดอร์นั้นมีอยู่แล้วหรือไม่ด้วยคำสั่ง `os.Stat()`
   - ถ้าโฟลเดอร์ไม่มีอยู่ (`os.IsNotExist(err)`), สร้างโฟลเดอร์ใหม่ด้วย `os.Mkdir()`

### ตัวอย่างการทำงาน:
เมื่อเรียก `createPath("/a/b/c/d/e")`:

- เริ่มจาก path `"/a/b/c/d/e/"`
- ฟังก์ชันจะวนลูปเพื่อสร้างโฟลเดอร์ตามลำดับ `/a`, `/a/b`, `/a/b/c`, `/a/b/c/d`, และ `/a/b/c/d/e`

## 2. ฟังก์ชัน `recursiveCreatePath`

ฟังก์ชันนี้ใช้วิธีการ **เรียกตัวเอง (recursion)** เพื่อตรวจสอบและสร้างโฟลเดอร์ทีละระดับจาก base path ที่กำหนด โดยมีโครงสร้างเป็นแบบ recursive function ซึ่งแบ่งออกเป็น **base case** และ **recursive case** ดังนี้:

### ขั้นตอนการทำงาน:

1. **Base Case (กรณีพื้นฐาน)**:
   - ถ้า path ที่รับเข้ามาไม่มี `/` อีกต่อไปแล้ว (เช่นเป็น path สุดท้าย) จะตรวจสอบว่าโฟลเดอร์มีอยู่หรือไม่ ถ้าไม่มีอยู่จะทำการสร้างโฟลเดอร์ (`os.Mkdir()`)

2. **Recursive Case (กรณีเรียกซ้ำ)**:
   - ถ้า path ที่รับเข้ามายังมี `/` อยู่ จะทำการแยกส่วนแรกของ path ออกมา (`curDir := basePath + "/" + path[:idx]`)
   - ตรวจสอบว่าโฟลเดอร์นั้นมีอยู่หรือไม่ ถ้าไม่มีอยู่จะทำการสร้างโฟลเดอร์
   - จากนั้นจะเรียกฟังก์ชัน `recursiveCreatePath` อีกครั้งด้วย base path ใหม่ที่เพิ่มโฟลเดอร์ปัจจุบันเข้าไป และส่วนที่เหลือของ path ที่ยังไม่ได้สร้าง

### ตัวอย่างการทำงาน:
เมื่อเรียก `recursiveCreatePath(".", "v/w/x/y/z")`:

- เริ่มจาก base path `.` และ path `v/w/x/y/z`
- ฟังก์ชันจะทำการสร้างโฟลเดอร์ตามลำดับ:
  - `./v`
  - `./v/w`
  - `./v/w/x`
  - `./v/w/x/y`
  - `./v/w/x/y/z`

## สรุปความแตกต่าง:

- **ฟังก์ชัน `createPath`**: ใช้การวนลูปเพื่อไล่สร้างโฟลเดอร์ทีละระดับ
- **ฟังก์ชัน `recursiveCreatePath`**: ใช้วิธีการเรียกตัวเอง (recursion) เพื่อสร้างโฟลเดอร์ทีละระดับ

ทั้งสองฟังก์ชันมีเป้าหมายเดียวกันคือการสร้าง path ที่ยังไม่มี แต่ใช้วิธีการที่ต่างกันในเชิงโครงสร้าง

---

การเปรียบเทียบ (เทรดออฟ) ของสองวิธีนี้เกี่ยวข้องกับประสิทธิภาพ โครงสร้าง และความง่ายในการใช้งาน ซึ่งสามารถพิจารณาได้ดังนี้:

### 1. **การใช้การวนลูป (Loop) ในฟังก์ชัน `createPath`**

#### **ข้อดี**:
- **ประสิทธิภาพ**: ฟังก์ชันนี้ใช้การวนลูปแบบธรรมดา (iterative) ทำให้มีประสิทธิภาพดีในเชิงของการใช้หน่วยความจำ ไม่ต้องใช้ stack ในการเก็บข้อมูลการเรียกซ้ำ
- **เข้าใจง่าย**: วิธีการวนลูปเป็นวิธีที่เข้าใจง่ายและตรงไปตรงมาสำหรับคนที่คุ้นเคยกับการเขียนโค้ดเชิงวนลูป
- **ไม่ต้องพึ่งพาหน่วยความจำเพิ่มเติม**: ไม่ต้องใช้พื้นที่หน่วยความจำเพิ่มเติมสำหรับ stack ในการจัดเก็บข้อมูลของฟังก์ชันที่เรียกซ้ำ

#### **ข้อเสีย**:
- **โค้ดยาวและดูซับซ้อนขึ้นเมื่อมีการจัดการกับ path**: การวนลูปและการจัดการกับ path เช่นการลบ `/` หรือตรวจสอบตำแหน่งของ `/` อาจทำให้โค้ดดูยาวและซับซ้อนมากขึ้น
- **ขยายยากเมื่อมีเงื่อนไขซับซ้อนขึ้น**: หากมีการขยายเพื่อรองรับกรณีที่ซับซ้อน เช่น path ที่มีรูปแบบไม่แน่นอน โค้ดอาจจะต้องถูกปรับเยอะขึ้น

---

### 2. **การใช้การเรียกตัวเอง (Recursion) ในฟังก์ชัน `recursiveCreatePath`**

#### **ข้อดี**:
- **โครงสร้างชัดเจน**: การใช้ recursion ทำให้โค้ดมีโครงสร้างที่ชัดเจน เพราะสามารถแบ่งปัญหาออกเป็นกรณีเล็ก ๆ และจัดการได้ในแต่ละระดับของ path
- **ขยายง่าย**: เมื่อ path ซับซ้อนขึ้น สามารถขยายฟังก์ชันได้ง่ายขึ้นโดยการเพิ่มกรณีใน base case และ recursive case
- **โค้ดกระชับ**: การใช้ recursion ทำให้โค้ดดูสั้นลงและสามารถอ่านและเข้าใจได้ง่ายโดยเฉพาะกับปัญหาที่มีรูปแบบโครงสร้างซ้ำๆ เช่น path ที่ซ้อนกันหลายระดับ

#### **ข้อเสีย**:
- **ใช้หน่วยความจำมากขึ้น**: เนื่องจาก recursion จะใช้ stack ในการเก็บข้อมูลการเรียกซ้ำ ดังนั้นหาก path มีความยาวมาก อาจเกิดปัญหา stack overflow ได้
- **อาจทำให้ประสิทธิภาพช้าลง**: ในบางกรณีที่มีการเรียกซ้ำบ่อย ๆ หรือ path ที่มีความลึกมาก การใช้ recursion อาจจะทำให้ช้ากว่าแบบวนลูป เนื่องจากต้องมี overhead ของการเรียกซ้ำ

---

### **สรุปเทรดออฟระหว่างสองวิธี**:

| เกณฑ์เปรียบเทียบ | `createPath` (วนลูป) | `recursiveCreatePath` (เรียกตัวเอง) |
|--------------------|-----------------------|--------------------------------------|
| **ประสิทธิภาพ**    | ดีกว่าในเรื่องการใช้หน่วยความจำและประสิทธิภาพโดยรวม | ใช้ stack มากกว่าและมี overhead การเรียกซ้ำ |
| **โครงสร้างโค้ด**   | อาจซับซ้อนและยาวเมื่อ path ซับซ้อนขึ้น | โครงสร้างชัดเจนและกระชับ เหมาะกับปัญหาแบบ recursive |
| **ความง่ายในการขยาย** | ต้องปรับโค้ดเยอะเมื่อมีเงื่อนไขใหม่ | ขยายง่ายโดยเพิ่มกรณี base case และ recursive case |
| **ความเสี่ยงในการทำงาน** | ความเสี่ยงต่ำในการเกิด stack overflow | มีความเสี่ยงในการเกิด stack overflow หาก recursion ลึกเกินไป |
| **การใช้หน่วยความจำ** | ใช้หน่วยความจำน้อยกว่า | ใช้ stack เพิ่มขึ้นในการเก็บ state ของการเรียกซ้ำ |

ทั้งสองวิธีมีข้อดีและข้อเสียตามสถานการณ์ ควรเลือกวิธีการที่เหมาะสมกับปัญหาเฉพาะหน้า เช่น ถ้า path มีระดับไม่มากและไม่ซับซ้อน อาจเลือกใช้ recursion เพื่อให้โค้ดกระชับ แต่หากต้องจัดการกับ path ที่มีความลึกมาก ควรเลือกใช้การวนลูปเพื่อประสิทธิภาพที่ดีกว่า