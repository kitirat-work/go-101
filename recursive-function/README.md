# Recursive Function

## องค์ประกอบของ Recursive Function

1. **Base Case (กรณีพื้นฐาน)**  
   เป็นเงื่อนไขที่บอกให้ฟังก์ชันหยุดการทำงานแบบเรียกตัวเอง (recursion) เมื่อเงื่อนไขนี้เป็นจริง ฟังก์ชันจะหยุดเรียกตัวเองและส่งค่ากลับ ตัวอย่างเช่น การนับถึงจำนวนที่กำหนดหรือการตรวจสอบว่าเราได้ถึงจุดสิ้นสุดของการดำเนินการแล้ว

2. **Recursive Case (กรณีเรียกซ้ำ)**  
   เป็นส่วนที่ฟังก์ชันเรียกตัวเองอีกครั้ง โดยมักจะส่งค่าหรือพารามิเตอร์ที่ปรับให้เล็กลงหรือใกล้เคียงกับ base case มากขึ้น ในทุกครั้งที่เรียกซ้ำ ฟังก์ชันจะเข้าใกล้ base case จนกว่าจะหยุดเรียกตัวเอง

## วิธีการเขียน Recursive Function

1. **เขียน Base Case ก่อน**  
   เพื่อป้องกันการวนลูปแบบไม่รู้จบและทำให้ฟังก์ชันรู้ว่าจะหยุดการเรียกซ้ำเมื่อใด  
   ตัวอย่าง:
   ```go
   if n == 0 {
       return 1
   }
   ```

2. **เขียน Recursive Case**  
   ในส่วนนี้จะเป็นการเรียกฟังก์ชันตัวเองด้วยค่าใหม่ที่เข้าใกล้ base case มากขึ้น  
   ตัวอย่าง:
   ```go
   return n * factorial(n - 1)
   ```

3. **ตรวจสอบการทำงานและการทดสอบด้วยค่าเริ่มต้นที่แตกต่างกัน**  
   ควรทดสอบฟังก์ชันด้วยค่า input หลายๆ แบบ เพื่อให้มั่นใจว่ามี base case และทำงานได้ถูกต้อง

## ตัวอย่างการเขียน Recursive Function

```go
func factorial(n int) int {
    if n == 0 { // Base Case
        return 1
    }
    return n * factorial(n - 1) // Recursive Case
}
```

ในตัวอย่างนี้ `factorial` คือฟังก์ชันคำนวณค่าทางคณิตศาสตร์ของตัวเลข โดยมีเงื่อนไขว่าเมื่อ `n == 0` ฟังก์ชันจะหยุดทำงานและส่งค่า `1` กลับมา ส่วนกรณีเรียกซ้ำจะทำงานเมื่อ `n > 0` โดยเรียกตัวเองใหม่และลดค่า `n` ลงเรื่อยๆ จนถึง base case

## ข้อดีของ Recursive Function

- ช่วยให้โค้ดกระชับและเข้าใจง่ายในบางปัญหา เช่น การหาค่า factorial, การหาลำดับของ Fibonacci หรือการหาค่าของโครงสร้างข้อมูลแบบต้นไม้ (tree)
- สามารถแก้ปัญหาที่มีโครงสร้างซ้ำซ้อนได้อย่างง่ายดาย

## ข้อควรระวัง

- การเขียน Recursive Function ที่ไม่มี base case หรือการเรียกซ้ำที่ไม่ได้เข้าใกล้ base case จะทำให้เกิดการวนลูปไม่สิ้นสุด
- ควรระมัดระวังเรื่องการใช้หน่วยความจำ เนื่องจาก Recursive Function อาจทำให้เกิด stack overflow เมื่อมีการเรียกซ้ำมากเกินไป